<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Introduction</title>
<link rel="next" href="Ch3_Preliminaries.html" title="Preliminaries" />
<link rel="prev" href="Ch1_AbstractAndAcknowledgements.html" title="Abstract and Summary" />
<link rel="up" href="index.html" title="Classification of finite subgroups of PGL" />
<link rel="stylesheet" href="styles/theme-white.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/extra_styles.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Classification of finite subgroups of PGL</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html"><span class="toc_ref">1</span> <span class="toc_entry">Abstract and Summary</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000003"><span class="toc_ref">1.1</span> <span class="toc_entry">Acknowledgements</span></a>
 </li>
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000004"><span class="toc_ref">1.2</span> <span class="toc_entry">Summary</span></a>
 </li>
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000005"><span class="toc_ref">1.3</span> <span class="toc_entry">How to read this blueprint</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000006"><span class="toc_ref">1.3.1</span> <span class="toc_entry">Navigating the blueprint</span></a>
 </li>
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000007"><span class="toc_ref">1.3.2</span> <span class="toc_entry">Note on <span class="ttfamily">remarks</span></span></a>
 </li>
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000009"><span class="toc_ref">1.3.3</span> <span class="toc_entry">Distinguishing my work from Christopher Butler’s work</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000010"><span class="toc_ref">1.4</span> <span class="toc_entry">Christopher Butler’s acknowledgements and popular science summary</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000011"><span class="toc_ref">1.4.1</span> <span class="toc_entry">Christopher Butler’s Abstract </span></a>
 </li>
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000012"><span class="toc_ref">1.4.2</span> <span class="toc_entry">Acknowledgements from Christopher Butler</span></a>
 </li>
<li class="">
  <a href="Ch1_AbstractAndAcknowledgements.html#a0000000013"><span class="toc_ref">1.4.3</span> <span class="toc_entry">Christopher Butler’s popular science summary</span></a>
 </li>

  </ul>
 </li>

  </ul>
 </li>
<li class=" active current">
  <a href="Ch2_Introduction.html"><span class="toc_ref">2</span> <span class="toc_entry">Introduction</span></a>
  <span class="expand-toc">▼</span>
  <ul class="sub-toc-1 active">
     <li class="">
  <a href="Ch2_Introduction.html#a0000000014"><span class="toc_ref">2.1</span> <span class="toc_entry">What is the formalisation of mathematics?</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch2_Introduction.html#a0000000015"><span class="toc_ref"></span> <span class="toc_entry">What is Lean?</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch2_Introduction.html#a0000000016"><span class="toc_ref">2.2</span> <span class="toc_entry">Fermat’s Last Theorem</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch2_Introduction.html#a0000000017"><span class="toc_ref"></span> <span class="toc_entry">Problem statement and its history</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch2_Introduction.html#a0000000018"><span class="toc_ref">2.3</span> <span class="toc_entry">Formalising Fermat’s Last Theorem</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch2_Introduction.html#a0000000019"><span class="toc_ref"></span> <span class="toc_entry">The first target of the formalisation of Fermat’s Last Theorem</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch2_Introduction.html#a0000000020"><span class="toc_ref">2.4</span> <span class="toc_entry">Classification of finite subgroups of the \(\operatorname{PGL}_2(\bar{\mathbb {F}}_p)\) within Fermat’s Last Theorem</span></a>
 </li>
<li class="">
  <a href="Ch2_Introduction.html#a0000000021"><span class="toc_ref">2.5</span> <span class="toc_entry">Overview and reduction to the classification problem</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch3_Preliminaries.html"><span class="toc_ref">3</span> <span class="toc_entry">Preliminaries</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="Ch3_Preliminaries.html#a0000000022"><span class="toc_ref">3.1</span> <span class="toc_entry">Some Elementary Theorems</span></a>
 </li>
<li class="">
  <a href="Ch3_Preliminaries.html#a0000000023"><span class="toc_ref">3.2</span> <span class="toc_entry">Sylow Theory</span></a>
 </li>
<li class="">
  <a href="Ch3_Preliminaries.html#a0000000024"><span class="toc_ref">3.3</span> <span class="toc_entry">Group Action</span></a>
 </li>
<li class="">
  <a href="Ch3_Preliminaries.html#a0000000025"><span class="toc_ref">3.4</span> <span class="toc_entry">Conjugation</span></a>
 </li>
<li class="">
  <a href="Ch3_Preliminaries.html#a0000000026"><span class="toc_ref">3.5</span> <span class="toc_entry">Automorphism</span></a>
 </li>
<li class="">
  <a href="Ch3_Preliminaries.html#a0000000027"><span class="toc_ref">3.6</span> <span class="toc_entry">Direct Product</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch4_ReductionOfProblem.html"><span class="toc_ref">4</span> <span class="toc_entry">Reduction of classification of finite subgroups of \(\operatorname{PGL}_2(\bar{\mathbb {F}}_p)\) to classification of finite subgroups of \(\operatorname{PSL}_2(\bar{\mathbb {F}}_p)\)</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="Ch4_ReductionOfProblem.html#a0000000028"><span class="toc_ref">4.1</span> <span class="toc_entry">Over an algebraically closed field \(\operatorname{PSL}_n(F)\) is isomorphic to the projective \(\operatorname{PGL}_n(F)\)</span></a>
 </li>
<li class="">
  <a href="Ch4_ReductionOfProblem.html#a0000000029"><span class="toc_ref">4.2</span> <span class="toc_entry">Christopher Butler’s exposition</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html"><span class="toc_ref">5</span> <span class="toc_entry">Properties of the two dimensional \(\operatorname{SL}_2(F)\)</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000030"><span class="toc_ref">5.1</span> <span class="toc_entry">General Notation</span></a>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000031"><span class="toc_ref">5.2</span> <span class="toc_entry">Subsets of \(\operatorname{SL}_2(F)\)</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000032"><span class="toc_ref"></span> <span class="toc_entry">Special matrices of \(\operatorname{SL}_2(F)\)</span></a>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000033"><span class="toc_ref"></span> <span class="toc_entry">Special subgroups of \(\operatorname{SL}_2(F)\)</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000034"><span class="toc_ref">5.3</span> <span class="toc_entry">The Center of \(\operatorname{SL}_2(F)\)</span></a>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000035"><span class="toc_ref">5.4</span> <span class="toc_entry">Conjugacy of the Elements of \(\operatorname{SL}_2(F)\)</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000036"><span class="toc_ref"></span> <span class="toc_entry">Classification of elements of \(\operatorname{SL}_2(F)\) up to conjugation</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000037"><span class="toc_ref">5.5</span> <span class="toc_entry">Centralizers &amp; Normalizers</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000038"><span class="toc_ref"></span> <span class="toc_entry">Normalizers</span></a>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000039"><span class="toc_ref"></span> <span class="toc_entry">Centralisers</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch5_PropertiesOfSLOverAlgClosedField.html#a0000000040"><span class="toc_ref">5.6</span> <span class="toc_entry">The Projective Line &amp; Triple Transitivity</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch6_MaximalAbelianSubgroupClassEquation.html"><span class="toc_ref">6</span> <span class="toc_entry">The Maximal Abelian Subgroup Class Equation</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="Ch6_MaximalAbelianSubgroupClassEquation.html#a0000000041"><span class="toc_ref">6.1</span> <span class="toc_entry">A finite subgroup of \(\operatorname{SL}_2(F)\)</span></a>
 </li>
<li class="">
  <a href="Ch6_MaximalAbelianSubgroupClassEquation.html#a0000000042"><span class="toc_ref">6.2</span> <span class="toc_entry">Maximal Abelian Subgroups</span></a>
 </li>
<li class="">
  <a href="Ch6_MaximalAbelianSubgroupClassEquation.html#a0000000043"><span class="toc_ref">6.3</span> <span class="toc_entry">Conjugacy of Maximal Abelian Subgroups</span></a>
 </li>
<li class="">
  <a href="Ch6_MaximalAbelianSubgroupClassEquation.html#a0000000044"><span class="toc_ref">6.4</span> <span class="toc_entry">Constructing The Class Equation</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="Ch7_DicksonsClassificationTheorem.html"><span class="toc_ref">7</span> <span class="toc_entry">Dickson’s Classification Theorem for finite subgroups of \(\operatorname{SL}_2(F)\)</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="Ch7_DicksonsClassificationTheorem.html#a0000000045"><span class="toc_ref">7.1</span> <span class="toc_entry">Five Lemmas</span></a>
 </li>
<li class="">
  <a href="Ch7_DicksonsClassificationTheorem.html#a0000000046"><span class="toc_ref">7.2</span> <span class="toc_entry">The Six Cases</span></a>
 </li>
<li class="">
  <a href="Ch7_DicksonsClassificationTheorem.html#a0000000047"><span class="toc_ref">7.3</span> <span class="toc_entry">Dickson’s Classification Theorem</span></a>
 </li>
<li class="">
  <a href="Ch7_DicksonsClassificationTheorem.html#a0000000048"><span class="toc_ref">7.4</span> <span class="toc_entry">Classification of finite subgroups of \(\operatorname{PGL}_2(\bar{\mathbb {F}}_p)\)</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="sect0001.html"><span class="toc_ref">8</span> <span class="toc_entry">Bibliography</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="Ch2_Introduction">2 Introduction</h1>

<h1 id="a0000000014">2.1 What is the formalisation of mathematics?</h1>
<p>Formalisation of mathematics is the art of teaching a computer what a piece of mathematics means. </p>
<p>That is, it is the process of carefully writing down a mathematical statement, typically in first order logic or higher order logic, and then scrutinously justifying each step of the proof to a computer program that checks the validity of every step of the reasoning. </p>
<p>Typically, one formalizes mathematics with the help of a proof assistant or what is also know as an interactive theorem prover, a piece of software which enables a human to write down mathematics and have the software verify the claims. </p>
<p>There exist many proof assistants, such examples are Lean, Isabelle, Coq, Metamath, and so forth. </p>
<p>For this project I have opted to use Lean due to its rapid growing mathematics library and its dependent type theory. I shall attempt to explain in more detail these last two reasons indirectly through examples, but first I will comment on what Lean is. </p>
<h3 id="a0000000015">What is Lean?</h3>
<p>Lean is both a functional programming language and an interactive theorem prover (also known as a proof assistant) that is being developed at Microsoft research and AWS by Leonardo de Moura and his team. It has been designed for both use in cutting-edge mathematics and the verification of software, which is often essential to safety critical systems such as medical or aviation software; where any error can have catastrophic consequences on people’s lives or expensive infrastructure. </p>
<p>Theorem provers like Lean harness the tight bond between proofs and programs. Often an algorithm, in fact serves as a proof for a mathematical statement. </p>
<p>For example, such is the case for the following theorem: </p>
<div class="example_thmwrapper theorem-style-remark" id="a0000000049">
  <div class="example_thmheading">
    <span class="example_thmcaption">
    Example
    </span>
    <span class="example_thmlabel">2.1</span>
    <span class="example_thmtitle">Algorithm corresponds to a proof - Bézout’s lemma</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="Ch2_Introduction.html#a0000000049">#</a>
    
    <a class="icon proof" href="Ch2_Introduction.html#a0000000050"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    
    
    
        </div>
  </div>
  <div class="example_thmcontent">
  <p> Let \(R\) be a ring with a euclidean function \(\nu : R \setminus \{ 0\}  \rightarrow \mathbb {Z}_{\geq 0}\) which satisfies that for all \(x, y \in R\) with \(y \ne 0\), there exist \(q, r \in \mathbb {R}\) such that \(a = qb + r\) where either \(r = 0\) or \(\nu (r) {\lt} \nu (b)\). </p>
<p>For any \(r,s \in R\) to find a unique linear combination which is the greatest common divisor of \(r\) and \(s\), that is, there exist coefficients \(a, b \in R\) such that \(ar + bs = \gcd (r, s)\). </p>

  </div>
</div>
<div class="proof_wrapper" id="a0000000050">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▶</span>
  </div>
  <div class="proof_content">
  <p>We construct \(a\) and \(b\) by the extended euclidean algorithm, we sequentially divide in the following fashion: </p>
<div class="displaymath" id="a0000000051">
  \begin{align}  r & = q_0 s + r_1\\ b & = q_1 r_1 + r_2\\ r_1 & = q_2 r_2 + r_3\\ & \vdots \\ r_{i-1} & = q_i r_i + r_{i + 1}& \end{align}
</div>
<p>by the definition of a euclidean domain, we have a strictly decreasing sequence \(\nu (r_1) {\gt} \nu (r_2) {\gt} \ldots {\gt} \nu (r_k)\) that must eventually terminate in at most \(\nu (r_1) + 1\) steps, and must have that \(\nu (r_k) = 0\) for some \(k \in \mathbb {N}\). It will then be that \(r_{k -1} = \gcd (r, s)\), and by back substitution we can recover the values for the coefficients \(a\) and \(b\). </p>

  </div>
</div>
<p>The proof for this theorem uses the extended euclidean algorithm and proves that when the algorithm terminates it produces the desired witnesses. In <span class="ttfamily">mathlib</span>, the extended euclidean algorithm is defined in the following way and is used to formalise Bézout’s lemma </p>
<p>It is not always clear how a proof corresponds to a program, but this correspondence does exist nonetheless. </p>
<p>The correspondence is known as the <b class="bfseries">Curry-Howard correspondence</b>, where formulas correspond to <i class="itshape">types</i>, which correspond to the notion of a specification; proofs for formulas correspond to constructing a term of the corresponding type and so forth. </p>
<p>In fact, it turns out that for every logic, such as classical or intuitionistic logic, there corresponds a type system which express the valid rules for programs. </p>
<p>For our purposes, we will not provide a deep overview of this fundamental correspondence, but rather we will illustrate the core principle with a suitable example. </p>
<p>Before we delve in to another example, observe that within the block of Lean code above there was a lot of unfamiliar syntax which one is somehow meant to believe correspond to mathematics. </p>
<p>The following example hopes to illustrate a simpler example and give a very brief overview of how to: </p>
<ul class="itemize">
  <li><p>Define the assumptions for a mathematical statement. </p>
</li>
  <li><p>Define the mathematical statement. </p>
</li>
  <li><p>Formalise the mathematical statement using Lean tactics. </p>
</li>
</ul>
<p>Note that in the list above, the notion of a Lean tactic is mentioned. Loosely speaking, a <span class="ttfamily">tactic</span> is a Lean metaprogram that will write Lean programs, these (non-meta) programs can be the usual code one would write for an algorithm or it could be the program which corresponds to the proof term that one needs to construct to formalise a mathematical statement in Lean. Examples of tactics and how they are used will be illustrated in the following example, yet a comprehensive list of Lean tactics can be found at <a href ="https://lean-lang.org/doc/reference/latest//Tactic-Proofs/Tactic-Reference/">Tactics</a>. </p>
<div class="example_thmwrapper theorem-style-remark" id="a0000000052">
  <div class="example_thmheading">
    <span class="example_thmcaption">
    Example
    </span>
    <span class="example_thmlabel">2.2</span>
    <span class="example_thmtitle">Proving and formalising the sum of the first \(n\) odd integers</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="Ch2_Introduction.html#a0000000052">#</a>
    
    
    
        </div>
  </div>
  <div class="example_thmcontent">
  <p> To understand how the nature of proof is preserved when passed into a theorem prover, we will compare side by side the informal and formal proofs for why the sum of the first \(n\) odd integers equals the \(n\)th square. That is, we will prove and formalise: </p>
<div class="equation" id="ih">
<p>
  <div class="equation_content">
    \begin{equation}  \label{ih} \sum _{k = 1}^{n} 2k - 1 = n^2 \end{equation}
  </div>
  <span class="equation_label">6</span>
</p>
</div>
<p>There are many ways to prove this statement, other proofs can be found at <span class="cite">
	[
	<a href="sect0001.html#sangwin" >2</a>
	]
</span>. The proof that is best suited to be formalised is the proof by induction which goes as the following: </p>
<div class="proof_wrapper" id="a0000000053">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▶</span>
  </div>
  <div class="proof_content">
  <p>We prove the claim holds for all \(n \in \mathbb {N}\) by the principle of mathematical induction. Indeed, </p>
<ul class="itemize">
  <li><p>The claim holds true for \(n = 1\) since the LHS is \(\sum _{k = 1}^{1} 2k -1 = 1\) and the RHS is \(1^2 = 1\) and indeed \(\textrm{LHS} = \textrm{RHS}\). This proves the base case. </p>
</li>
  <li><p>Let \(m \in \mathbb {N}\) be a natural number and suppose the statement <a href="Ch2_Introduction.html#ih" class="eqref">6</a> holds for \(n = m\) then we will show that it then follows that it must hold for \(n = m + 1\). Indeed, </p>
<p>Consider the sum \(\sum _{k = 1}^{m + 1} 2k - 1\), then we have that </p>
<div class="displaymath" id="a0000000054">
  \begin{align}  \sum _{k = 1}^{m + 1} 2k - 1 & = \left(\sum _{k = 1}^{m} 2k - 1\right) + 2(m + 1) - 1 \tag {by definition of the summation}\\ & = m^2 + 2m + 1 \tag {by the induction hypothesis}\\ & = (m + 1)^2 \end{align}
</div>
<p>This proves the induction step, and therefore by the principle of mathematical induction. The claim holds true for all \(n \in \mathbb {N}\). </p>
</li>
</ul>

  </div>
</div>
<p>To define this statement in Lean we first must define what we mean by \(\sum _{k = 1}^{n} 2k - 1\), to define this sum in Lean we use the recursive definition for the summation where </p>
<div class="displaymath" id="a0000000055">
  \begin{align*}  \sum _{k = 1}^{n + 1} f(k) & = \sum _{k = 1}^{n} f(k) + f(n + 1) \tag {for $n \geq 0$}\\ & \text{and}\\ \sum _{k = 1}^{0} f(k) & = 0 \end{align*}
</div>
<p>Where it is noteworthy to add that in Lean that naturals numbers include zero. </p>
<p>This definition above which sums the odd numbers is equivalent up to re-indexing to the definition above. </p>
<p>The reason we do not use subtraction is because the natural numbers are a commutative semiring, so it does not always make sense to subtract a natural number from a another natural number. For instance, the predecessor of zero is not defined. </p>
<p>Instead to understand a generic natural number we only need understand that a natural number is either zero or a successor of a natural number. Thus, when defining a function from the naturals, we only need to think about where to send zero and where to send the successor of a natural number, such a definition for a function are often denoted as inductive/recursive definitions. This pattern of thought is continually used throughout Lean’s inductive types. </p>
<p>Given the code definition above is a program one can indeed compute using the function defined in this programming language! </p>
<p>In fact, this might be how one would first conjecture that such a theorem about the sums of the first odd natural numbers might be true in the first place! </p>
<p>To state the theorem in Lean, we use the keyword <span class="ttfamily">theorem</span> or <span class="ttfamily">lemma</span>; followed by the name we would like to give the theorem, in this case it is, <span class="ttfamily">closed_eq_sum_of_first_n_odd_nat</span>; then followed by a list of arguments which will either be the objects or assumptions on the objects, in this case we only specify that <span class="ttfamily">n</span> is a natural number; then after a colon <span class="ttfamily">:</span>, we specify the mathematical statement, in this case that <span class="ttfamily">sum_of_first_n_odd_nat n = n * n</span>. We have stated our first mathematical statement in Lean! </p>
<p>Now we will walk through the formal proof in Lean: </p>
<p>After the <span class="ttfamily">:=</span> Lean expects a proof term of the type <span class="ttfamily">sum_of_first_n_odd_nat n = n * n</span>. It is possible to define the corresponding program which constructs the term, but often it is more intuitive to enter what is known as <i class="itshape">tactic mode</i>. </p>
<p>As outlined above, tactics are metaprograms, programs that write programs, which in this case allow the simulation of typical pen-and-paper mathematics in Lean; to enter tactic mode one must begin the proof with the <span class="ttfamily">by</span> tactic. A benefit of using tactic mode is that it allows access to an extremely useful interactive <i class="itshape">infoview</i> which displays the objects at play in the proof, the assumptions on the objects and the state of the proof. </p>
<p>Once in tactic mode, we have access to other tactics accessible through the keywords like: <span class="ttfamily">induction</span>, <span class="ttfamily">case</span>, <span class="ttfamily">rw</span>, <span class="ttfamily">rw</span>, <span class="ttfamily">ring</span>, <span class="ttfamily">simp</span> and so on. </p>
<p>Given the natural numbers are defined inductively in Lean, Lean understands that to prove that a property \(P\) holds true for all natural numbers it is sufficient to provide a proof term for \(P(0)\) and supposing \(P(n)\) holds we can show that then \(P(n+1)\) holds, in Lean terminology, the natural numbers have their own induction principle; notice the similarity to defining a function from the naturals. In fact, the generation of an induction principle will be automatically true for any inductive datatype, but we will not go into this. </p>
<p>To access this fact, we must invoke the <span class="ttfamily">induction</span> tactic which splits the original goal of <span class="ttfamily">sum_of_first_n_odd_nat n = n * n</span> into two smaller goals </p>
<ol class="enumerate">
  <li><p>The base case: <span class="ttfamily">sum_of_first_n_odd_nat 0 = 0 * 0</span>. </p>
</li>
  <li><p>The induction step: <span class="ttfamily">sum_of_first_n_odd_nat (m + 1) = (m + 1) * (m + 1)</span> </p>
</li>
</ol>
<p>The <span class="ttfamily">case</span> tactic allows us to focus in on one of the tactics, at first we focus on the goal with the label <i class="itshape">zero</i> to prove the base case; then we focus in on the induction step by typing <span class="ttfamily">case succ m hm</span> which also introduces two new objects into the proof context, the natural number \(m\) and the assumption on <span class="ttfamily">m</span> which says that \(m\) satisfies the induction hypothesis, <span class="ttfamily">sum_of_first_n_odd_nat m = m * m</span>. </p>
<p>We then proceed to use the rewrite tactic, <span class="ttfamily">rewrite</span>, which allows to replace equal or logically equivalent terms, so if you have the theorem <span class="ttfamily">h : a = b</span>, then <span class="ttfamily">rw [h]</span> will replace every occurrence of <span class="ttfamily">a</span> in the goal for a <span class="ttfamily">b</span>, in the new modified goal. For this particular example, the proof for the base case labelled by <span class="ttfamily">zero</span> involves using the rewrites <span class="ttfamily">mul_zero</span> which states that <span class="ttfamily">a * 0 = 0</span> and the definition of <span class="ttfamily">sum_of_first_n_odd_nat</span> itself, where Lean is clever enough to choose which of two equalities to rewrite. </p>
<p>Finally, <span class="ttfamily">rfl</span> proves any goal that is true by reflexivity of the given relation; in this case, we finish proving the goal by reflexivity of the equality relation. Typically, one uses the <span class="ttfamily">rw</span> tactic which is a combination of <span class="ttfamily">rewrite</span> followed by <span class="ttfamily">rfl</span>. </p>
<p>Theorems and lemmas in Lean are given an identifier by which to access through, for example, the theorem <span class="ttfamily">add_mul_self_eq</span> states that for all \(a, b \in S\) where \(S\) is a semiring we have that <span class="ttfamily">(a + b) * (a + b) = a * a + 2 * a * b + b * b</span>. </p>

  </div>
</div>
<h1 id="a0000000016">2.2 Fermat’s Last Theorem</h1>
<h3 id="a0000000017">Problem statement and its history</h3>
<p> Fermat’s Last Theorem, before it was proved that is, A conjecture about the <i class="itshape">Fermat equation</i> which is defined to be </p>
<div class="definition_thmwrapper theorem-style-definition" id="a0000000056">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">2.3</span>
    <span class="definition_thmtitle">Fermat Equation</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="Ch2_Introduction.html#a0000000056">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p> The equation \(a^n + b^n = c^n\) is Fermat’s Equation </p>

  </div>
</div>
<p>When \(a, b, c\) and \(n\) in this equation are restricted to positive integers, we are defining a particular family of what are called <i class="itshape">Diophantine equation</i>. Diophantus, an ancient greek mathematician was interested in positive integers which satisfy this equation. For instance, a particular set of numbers which satisfy this equation are the <i class="itshape">Pythagorean triples</i>, such triples have been known since Babylonian times. For example, when we substitute the Pythagorean triple \((a,b,c) = (3,4,5)\) and set \(n = 2\) we find that indeed Fermat’s equation holds for this choice of numbers since: </p>
<div class="displaymath" id="a0000000057">
  \[  3^2 + 4^2 = 5^2  \]
</div>
<p>In fact, much is known about the case when \(n = 2\); it is known that all Pythagorean triples are of the form: </p>
<div class="theorem_thmwrapper theorem-style-plain" id="a0000000058">
  <div class="theorem_thmheading">
    <span class="theorem_thmcaption">
    Theorem
    </span>
    <span class="theorem_thmlabel">2.4</span>
    <span class="theorem_thmtitle">Pythagorean triples</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="Ch2_Introduction.html#a0000000058">#</a>
    
    
    
        </div>
  </div>
  <div class="theorem_thmcontent">
  <p> All pythagorean triples are of the form: </p>
<div class="displaymath" id="a0000000059">
  \[  a = r \cdot (s^2 - t^2), \qquad b = r \cdot (2st), \qquad c = r \cdot (s^2 + t^2)  \]
</div>
<p>where \(s {\gt} t {\gt} 0\). </p>

  </div>
</div>
<p>The natural question to ask from such an extremely satisfying theorem is whether the same can be said for when \(n \ge 2\). Initially, mathematicians set out to to find solutions \(n = 3\). However, it seemed only the "trivial" triple satisfied Fermat’s equation for when \(n = 2\) </p>
<div class="displaymath" id="a0000000060">
  \[  0^3 + 1^3 = 1^3  \]
</div>
<p>Among these mathematicians was Pierre de Fermat, who suspected it was not possible to find a nontrivial triple for the exponent \(n= 3\) and what is more he believed it was not possible to find any nontrivial triple for any exponent \(n {\gt} 2\). In fact, Pierre de Fermat wrote in the margin of his copy of <i class="itshape">Arithmetic</i> written by Diophantus: " It is impossible... for any number which is a power greater than the second to be written as the sum of two like powers </p>
<div class="displaymath" id="a0000000061">
  \[  x^n + y^n = z^n \text{ for } n {\gt} 2.  \]
</div>
<p> I have a truly marvelous demonstration of this proposition which this margin is too narrow to contain. " </p>
<p>This copy and many of Pierre de Fermat’s belongings were searched in the hope of finding such a proof. Nonetheless, to this date no proof has been found. </p>
<p>It took Euler to provide a (flawed) proof for the nonexistence of nontrivial solutions to Fermat’s equation for the exponent \(n = 3\), so far so good, Fermat’s conjecture held true for \(n = 3\). The case where \(n = 4\) was also proved by Euler; soon enough particular cases where \(n\) was some fixed natural number where being shown, which indeed seemed to suggest Fermat’s conjecture was true. However, no approach seemed to generalise to prove the general case... </p>
<p>The proof of Fermat’s Last Theorem is the culmination of the effort of mathematicians spanning generations, and it took the direct and indirect efforts of mathematicians like: Gauss, Galois, Euler, Abel, Dedekind, Noether, Euler, Kummer, Mazur, Kronecker and so on to put Andrew Wiles and his collaborator Richard Taylor in the position to finally put to rest Fermat’s Last Theorem. </p>
<h1 id="a0000000018">2.3 Formalising Fermat’s Last Theorem</h1>
<p>Following the sequence of Lean success stories ranging from the Liquid Tensor Experiment to the formalisation of the Polynomial Freiman-Rusza conjecture. </p>
<p>Prof. Kevin Buzzard from Imperial College London has received a five-year grant that will allow him to lead the formalisation of Fermat’s Last Theorem. This grant kicked in in October of 2024. </p>
<p>At the time of writing, since October of 2024, a digital blueprint has been set up to manage the project. Alongside other infrastructure like the project dashboard, mathematicians around the world can claim tasks that are set by Prof. Kevin Buzzard and if in return a task is returned with a <span class="ttfamily">sorry</span> free proof then one can claim the glory of having completed the task. </p>
<h3 id="a0000000019">The first target of the formalisation of Fermat’s Last Theorem</h3>
<p>The goal of the ongoing efforts of the formalisation is to reduce the proof of Fermat’s Last Theorem to results that were known in the 1980s such as Mazur’s Theorem which bounds the torsion subgroup points of an elliptic curve. </p>
<p>However, it should be mentioned that the proof being formalised is not the original proof Andrew Wiles and Richard Taylor provided in 1994, but a more modernised approach that has been refined over the last 20 years. </p>
<p>At the time of writing, the first target set by Prof. Kevin Buzzard is to formalise the <b class="bfseries">Modularity Lifting Theorem</b> </p>
<p>After all, the ultimate goal is to formalise all of mathematics and so far the library relevant to Algebraic Number Theory, Algebraic Geometry and Arithmetic Geometry is not developed enough to be even able to state the propositions and let alone formalise their corresponding proofs. </p>
<p>Morally, the goal of the formalisation of Fermat’s Last Theorem is to formalise much of Algebraic Number Theory, Algebraic Geometry, Arithmetic Geometry and so forth so that one day the mathematics library of Lean <span class="ttfamily">mathlib</span>, contains all mathematics known to human kind. </p>
<h1 id="a0000000020">2.4 Classification of finite subgroups of the \(\operatorname{PGL}_2(\bar{\mathbb {F}}_p)\) within Fermat’s Last Theorem</h1>
<p>The primary goal for this project is to formalise Theorem 2.47 of <span class="cite">
	[
	<a href="sect0001.html#dtt" >3</a>
	]
</span> which concerns the projective general and special linear groups: </p>
<div class="definition_thmwrapper theorem-style-definition" id="a0000000062">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">2.5</span>
    <span class="definition_thmtitle">Projective general linear group</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="Ch2_Introduction.html#a0000000062">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p> The projective general linear group is the quotient group </p>
<div class="displaymath" id="a0000000063">
  \[  \operatorname{PGL}_n(F) = \operatorname{GL}_n(F) / (Z(\operatorname{GL}_n(F))) = \operatorname{GL}_n(F) / (F^\times I)  \]
</div>

  </div>
</div>
<p>Similarly, the Projective Special Linear Group is defined to be: </p>
<div class="definition_thmwrapper theorem-style-definition" id="a0000000064">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">2.6</span>
    <span class="definition_thmtitle">Projective special linear group</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="Ch2_Introduction.html#a0000000064">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <div class="displaymath" id="a0000000065">
  \[  \operatorname{PSL}_n(F) = \operatorname{SL}_n(F) / (Z(\operatorname{SL}_n(F))) = \operatorname{SL}_n(F) / (\langle -I\rangle )  \]
</div>

  </div>
</div>
<p>The theorem states: </p>
<ol class="enumerate">
  <li><p>If \(H\) is finite subgroup of \(\operatorname{PGL}_2(\mathbb {C})\) then \(H\) is isomorphic to one of the following groups: the cyclic group \(C_n\) of order \(n\) (\(n \in \mathbb {Z}_{{\gt}0}\)), the dihedral group \(D_{2n}\) of order \(2n\) (\(n \in \mathbb {Z}_{{\gt}1}\)), \(A_4\), \(S_4\) or \(A_5\). </p>
</li>
  <li><p>If \(H\) is a finite subgroup of \(\operatorname{PGL}_2(\bar{\mathbb {F}}_\ell )\) then one of the following holds: </p>
<ol class="enumerate">
  <li><p>\(H\) is conjugate to a subgroup of the upper triangular matrices; </p>
</li>
  <li><p>\(H\) is conjugate to \(\operatorname{PGL}_2(\mathbb {F}_{\ell ^r})\) and \(\operatorname{PSL}_2(\mathbb {F}_{\ell ^{r}})\) for some \(r \in \mathbb {Z}_{{\gt}0}\); </p>
</li>
  <li><p>\(H\) is isomorphic to \(A_4\), \(S_4\), \(A_5\) or the dihedral group \(D_{2r}\) of order \(2r\) for some \(r \in \mathbb {Z}_{{\gt}1}\) not divisible by \(\ell \) </p>
</li>
</ol>
<p> Where \(\ell \) is assumed to be an odd prime. </p>
</li>
</ol>
<p>Upon inspection of the proof, it turns out that Theorem 2.47 of <span class="cite">
	[
	<a href="sect0001.html#dtt" >3</a>
	]
</span> is required to prove the results: Theorem 2.49, Remark 2.47 and Lemma 4.11. Where Theorem 2.49 states: </p>
<div class="theorem_thmwrapper theorem-style-plain" id="a0000000066">
  <div class="theorem_thmheading">
    <span class="theorem_thmcaption">
    Theorem
    </span>
    <span class="theorem_thmlabel">2.7</span>
    <span class="theorem_thmtitle">Theorem 2.49</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="Ch2_Introduction.html#a0000000066">#</a>
    
    
    
        </div>
  </div>
  <div class="theorem_thmcontent">
  <p> Suppose \(L = \mathbb {Q}(\sqrt{(-1)^{\ell -1}/2} \ell )\) then \(\bar{\rho }\) is absolutely irreducible. Then there exists a non-negative integer \(r\) such that for any \(n \in \mathbb {Z}_{{\gt}0}\) we can find a finite set of primes \(Q_n\) with the following properties. </p>
<ol class="enumerate">
  <li><p>If \(q \in Q_n\) then \(q \equiv 1 \mod n\). </p>
</li>
  <li><p>If \(q \in Q_n\) then \(\bar{\rho }\) is unramified at \(q\) and \(\rho (\textrm{Frob}q)\) has distinct eigenvalues. </p>
</li>
  <li><p>\(\#  Q_n = r\). </p>
</li>
</ol>

  </div>
</div>
<p>The place where the theorem 2.47 is of interest, the theorem that this project aims to be a blueprint for, is because proving proving the claim above requires showing that the cohomology group \(H^1(\textrm{Gal}(F_n / F_0), \textrm{ad}^0\bar{\rho }(1))^G_{\mathbb {Q}}\) is trivial, which in turn reduces to showing that \(\ell \), an odd prime, does not divide the Galois group \(\operatorname{Gal}(F_0 /\mathbb {Q})\) which is isomorphic to a finite subgroup \(\operatorname{PGL}_2(\bar{\mathbb {F}}_\ell )\) and has \(\operatorname{Gal}(\mathbb {Q}(\zeta _\ell )/\mathbb {Q})\) as a quotient. </p>
<p>Provided the classification of finite subgroups of \(\operatorname{PGL}_2(\bar{\mathbb {F}}_\ell )\), it suffices to prove that the cohomology group is trivial for the case where \(\ell = 3\). </p>
<h1 id="a0000000021">2.5 Overview and reduction to the classification problem</h1>
<p>Returning to the domain of the problem of interest, classifying finite subgroups of \(\operatorname{PGL}_2(\bar{\mathbb {F}}_p)\); one observe that \(\bar{\mathbb {F}}_p\) is by construction an algebraically closed field, since it is the algebraic closure of \(\mathbb {F}_p\), and it turns out that for any \(n \in \mathbb {N}\), it is possible to show that \(\operatorname{PGL}_n(F)\) is isomorphic to \(\operatorname{PSL}_n(F)\) for any algebraically closed field \(F\), thus reducing our original classification of finite subgroups to the classification of finite subgroups of \(\operatorname{PSL}_2(\bar{\mathbb {F}})\). </p>
<p>Furthermore, on the back of the isomorphism defined between \(\operatorname{PGL}_2(\bar{\mathbb {F}}_p)\) and \(\operatorname{PSL}_2(\bar{\mathbb {F}}_p)\), and determining that the center of \(\operatorname{SL}_2(\bar{\mathbb {F}}_p)\) is \(Z(\operatorname{SL}_2(\bar{\mathbb {F}}_p)) = \langle -I\rangle \), we can in fact focus on the much more tractable problem of classifying the finite subgroups of \(SL_2(\bar{\mathbb {F}}_p)\) to eventually classify the finite subgroups of \(\operatorname{PSL}_2(\bar{\mathbb {F}}_p)\), and overall obtain our desired result. </p>
<p>Moreover, since the more general problem of classifying the finite subgroups of \(\operatorname{SL}_2(F)\) where \(F\) is an arbitrary algebraically closed field yields a statement that is very close to the desired statement and Christopher Butler has a in-depth exposition of this result, the formalisation of the slightly more general result was chosen. </p>
<p>Considering proving the existence of such an isomorphism \(\operatorname{PGL}_2(\bar{\mathbb {F}}_p)\) and \(\operatorname{PSL}_2(\bar{\mathbb {F}}_p)\) is no more difficult in the general case, the goal of the next chapter will be to formalise the definition of a suitable homomorphism between \(\operatorname{PGL}_n(F)\) and \(\operatorname{PSL}_n(F)\), where \(F\) is an algebraically closed field, and formally prove in the Lean proof assistant that this homomorphism actually defines an isomorphism. </p>
<p>But before we dive into proving and formalising this result, we recall some preliminary results that will be used throughout the blueprint. </p>

</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="Ch1_AbstractAndAcknowledgements.html" title="Abstract and Summary"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Classification of finite subgroups of PGL"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="Ch3_Preliminaries.html" title="Preliminaries"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>