-- import Mathlib

-- def sum_of_odd : ℕ → ℕ
--  | 0 => 0
--  | n + 1 => sum_of_odd n + (2*n + 1)

-- #eval sum_of_odd 50


-- theorem sum_of_odd_eq_sq : ∀ n : ℕ, sum_of_odd n = n^2 := by
--   intro n
--   induction n
--   case zero => rw [sum_of_odd, sq, mul_zero]
--   case succ k hk =>
--     rw [sum_of_odd, hk, sq, sq]
--     ring


-- #moogle "add multiplied by self."

-- #check add_mul_self_eq

-- #synth CommSemiring ℕ


-- lemma exists_sqrt_discriminant [IsAlgClosed F] { a b c : F} :
--   ∃ s, s * s = discrim a b c := by
--   rw [discrim]
--   let P := C 1 * X^2 + C 0 * X + C (- (b^2 - 4 * a * c))
--   have deg_P_eq_two : degree P = 2 := by
--     dsimp [P]
--     rw [Polynomial.degree_quadratic]
--     exact one_ne_zero
--   have exists_root_of_P := by apply IsAlgClosed.exists_root P (by simp [deg_P_eq_two])
--   obtain ⟨s, hs⟩ := exists_root_of_P
--   use s
--   simp [P] at hs
--   rw [add_eq_zero_iff_eq_neg, sq] at hs
--   rw [hs]
--   ring_nf

-- def GeneralLinearGroup.T [DecidableEq F] (a b d : F) : GL (Fin 2) F :=
--   if h : a * d ≠ 0
--   then GeneralLinearGroup.mk' !![a, b; 0, d] (by simp; exact invertibleOfNonzero h)
--   else 1

-- lemma smul_one_of_minpoly_eq_X_sub_C { R : Type*} {n : ℕ} [ CommRing R ] [NoZeroDivisors R]
--   {s : (Fin n → R) →ₗ[R] Fin n → R } {a : R} (hs : Associated (minpoly R s) (X - C a)) :
--   s = a • 1 := by
--   obtain ⟨unit, hunit⟩ := hs
--   let Ξ := minpoly R s
--   -- The minimal polynomial evaluated at M must be 0
--   have s_eq_smul_one : aeval s Ξ = 0 := minpoly.aeval _ _
--   have Ξ_eq : ∃ u_inv, IsUnit u_inv ∧ Ξ = (X - C a) * u_inv := ⟨unit.inv, by simp [← hunit]⟩
--   -- We rearrange Ξ_eq to isolate Ξ, and plug in Ξ
--   obtain ⟨u_inv, u_inv_is_unit, Ξ_eq⟩ := Ξ_eq
--   rw [Polynomial.isUnit_iff] at u_inv_is_unit --------
--   obtain ⟨u_inv', u_inv'_is_unit, C_u_inv'_eq_u_inv⟩  := u_inv_is_unit
--   have ringHom_u_inv'_is_unit : IsUnit ((algebraMap R ((Fin n → R) →ₗ[R] Fin n → R)) u_inv') :=
--     RingHom.isUnit_map _ u_inv'_is_unit
--   rw [Ξ_eq, aeval_mul, ← C_u_inv'_eq_u_inv, aeval_C,
--     IsUnit.mul_left_eq_zero ringHom_u_inv'_is_unit] at s_eq_smul_one
--   simp [map_sub, aeval_X, aeval_C, sub_eq_zero, algebraMap, Algebra.toRingHom] at s_eq_smul_one
--   -- This shows S is diagonal
--   exact s_eq_smul_one


-- def GeneralLinearGroup.D { F : Type* } [DecidableEq F] [Field F] (a d : F) : GL (Fin 2) F :=
--   if h : a * d ≠ 0 then (GeneralLinearGroup.mk' (diagonal (fun i => if i = 0 then a else d)) (by simp; exact invertibleOfNonzero h)) else 1

-- def GeneralLinearGroup.J { F : Type* } [DecidableEq F] [Field F] (a d : F) : GL (Fin 2) F :=
--   if h : a * d ≠ 0 then GeneralLinearGroup.mk' !![(a : F), (1 : F); (0 : F), (d : F)] (by simp; exact invertibleOfNonzero h) else 1

-- lemma lin_map_eq_iff_matrix_eq { n R : Type* } [ Fintype n] [ DecidableEq n ] [CommRing R] { A B :  GL n R }(h : Matrix.toLin' (A : Matrix n n R) = Matrix.toLin' B ) : A = B := by
--   apply Matrix.GeneralLinearGroup.ext
--   rw [EmbeddingLike.apply_eq_iff_eq, ← Matrix.ext_iff] at h
--   exact h

-- open Polynomial in
-- theorem theorem_1_5₂ [IsAlgClosed F] (S : SL(2,F)) : (∃ δ : Fˣ, @IsConj (GL (Fin 2) F) _ S (D δ)) ∨ (∃ τ : F, @IsConj (GL (Fin 2) F) _ S (T τ)) := by
--   let inst1 : PerfectField F := IsAlgClosed.perfectField F
--   obtain ⟨n, hn, f, hf, n_is_nilpotent, f_is_semisimple, hfn⟩ := @Module.End.exists_isNilpotent_isSemisimple F ((Fin 2) → F) _ _ _ (@toEnd F _ S) _ _--((toLinAlgEquiv (Pi.basisFun F (Fin 2))) S)
--   rw [← LinearMap.isNilpotent_toMatrix_iff (Pi.basisFun F (Fin 2))] at n_is_nilpotent
--   rw [@Module.End.isSemisimple_iff] at f_is_semisimple

--   -- Obtain eigenvalue, ξ₁ and eigenvector v₁
--   obtain ⟨ξ₁, hξ₁⟩ := by apply Module.End.exists_eigenvalue f--(Matrix.toLin (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) (S : Matrix (Fin 2) (Fin 2) F))
--   obtain ⟨v₁, hv₁, v₁_ne_zero⟩ := by apply Module.End.HasEigenvalue.exists_hasEigenvector hξ₁
--   -- Define the submodule generated by v₁
--   let H₁ := Submodule.span F {v₁}
--   have rank_H₁_leq_one_cardinal : Module.rank F H₁ ≤ 1 := by
--     dsimp [H₁]
--     rw [rank_submodule_le_one_iff]
--     exact ⟨v₁, mem_span_singleton_self _, le_refl _⟩
--   have rank_H₁_not_lt_one_cardinal : ¬ Module.rank F H₁ < 1 := by simp [H₁, v₁_ne_zero]
--   have rank_H₁_eq_one_cardinal : Module.rank F H₁ = 1 := by apply eq_of_le_of_not_lt rank_H₁_leq_one_cardinal rank_H₁_not_lt_one_cardinal
--   have rank_H₁_eq_one := Module.rank_eq_one_iff_finrank_eq_one.mp rank_H₁_eq_one_cardinal
--   have H₁_submodule_of_comap :  H₁ ≤ Submodule.comap f H₁:= by
--     intro w hw
--     simp [H₁, LinearMap.span_singleton_eq_range] at hw ⊢
--     rw [Module.End.mem_unifEigenspace_one] at hv₁
--     rcases hw with ⟨α, rfl⟩
--     use α * ξ₁
--     rw [LinearMap.map_smul, hv₁, smul_smul]
--     done
--   -- From Jordan-Chevallier obtain complementary submodule H₂
--   obtain ⟨H₂, H₂_submodule_of_comap, H₁_is_compl_to_H₂⟩ := f_is_semisimple H₁ H₁_submodule_of_comap
--   rcases H₁_is_compl_to_H₂ with ⟨H₁_disjoint_H₂, H₁_codisjoint_H₂⟩
--   apply Disjoint.le_bot at H₁_disjoint_H₂
--   apply Codisjoint.top_le at H₁_codisjoint_H₂
--   rw [le_bot_iff, ← Submodule.zero_eq_bot] at H₁_disjoint_H₂
--   rw [top_le_iff] at H₁_codisjoint_H₂
--   -- by_cases exists_v_in_H₂ : ∃ v ∈ H₂, v ∉ LinearMap.ker (f - ξ₁ • 1)
--   -- obtain ⟨v₂, v₂_in_H₂, v₂_not_in_eigenspace_f_ξ₁⟩ := exists_v_in_H₂
--   -- have v₂_subset_H₂: {v₂} ⊆ (H₂ : Set (Fin 2 → F)) := by
--   --       intro v hv
--   --       rcases hv with ⟨rfl⟩
--   --       exact v₂_in_H₂
--   -- -- We now show v₂ generates H₂
--   -- have v₂_ne_zero : v₂ ≠ 0 := by
--   --   by_contra h
--   --   have v₂_in_eigenspace_f_ξ₁ : v₂ ∈ LinearMap.ker (f - ξ₁ • 1) := by rw [h]; exact Submodule.zero_mem _
--   --   contradiction
--   -- have v₂_not_in_H₁ : v₂ ∉ H₁ := by
--   --   intro v₂_in_H₁
--   --   have v₂_in_meet : v₂ ∈ H₁ ⊓ H₂ := Submodule.mem_inf.mpr ⟨v₂_in_H₁, v₂_in_H₂⟩
--   --   rw [H₁_disjoint_H₂, zero_eq_bot, Submodule.mem_bot] at v₂_in_meet
--   --   -- v₂ = 0  and v₂ ≠ 0, a contradiction
--   --   contradiction
--   have rank_nullity := rank_sup_add_rank_inf_eq H₁ H₂
--   rw [
--     H₁_disjoint_H₂, zero_eq_bot, rank_bot, add_zero, H₁_codisjoint_H₂, rank_top,
--     rank_H₁_eq_one_cardinal, rank_fin_fun
--   ] at rank_nullity
--   have rank_H₂_leq_one_cardinal : Module.rank F H₂ ≤ 1 := by
--     by_contra not_leq
--     simp at not_leq
--     have : (2 : Cardinal.{u}) < 2 :=
--       calc
--         2 = 1 + Module.rank F ↥H₂ := by apply rank_nullity
--         _ < 1 + 1 := by sorry--apply add_lt_add_left
--         _ = 2 := by rw [one_add_one_eq_two]
--     -- linarith should work :(
--     norm_num at this
--   have exists_generator_for_H₂ : ∃ v ∈ H₂, H₂ ≤ span F {v} := by rw [← rank_submodule_le_one_iff]; exact rank_H₂_leq_one_cardinal
--   obtain ⟨v₂, v₂_in_H₂, H₂_leq_span_v₂⟩ := exists_generator_for_H₂
--   have v₂_generates_H₂ : span F {v₂} = H₂ := by
--     ext w
--     constructor
--     · intro w_in_span_v₂
--       rw [LinearMap.span_singleton_eq_range] at w_in_span_v₂
--       obtain ⟨α, rfl⟩ := w_in_span_v₂
--       simp [smul_mem, v₂_in_H₂]
--     · intro w_in_H₂
--       exact H₂_leq_span_v₂ w_in_H₂
--       done
--   -- We show nilpotent part is either 0 or is zero every except the top right entry
--   by_cases h : (∃ v : Fin 2 → F, v ∉ LinearMap.ker n)
--   -- the nilpotent part, n is conjugate to [[0,0],[1,0]]
--   obtain ⟨v, hv⟩ := h
--   obtain ⟨m, hm⟩ := n_is_nilpotent
--   sorry
--   -- nilpotent part equals zero, n = 0, so f + n = f and so when changing basis
--   sorry

-- lemma jordan_normal_expl_2 { F : Type*} [Field F] [DecidableEq F] [IsAlgClosed F] { G : GL (Fin 2) F} : ∃ a d : F, a * d ≠ 0 ∧ (IsConj G (GeneralLinearGroup.D a d) ∨ IsConj G (GeneralLinearGroup.J a d ))  := by
--   let g := Matrix.toLin' (G : Matrix (Fin 2) (Fin 2) F)
--   have det_G_ne_zero : det (G : Matrix (Fin 2) (Fin 2) F) ≠ 0 := by sorry
--   have G_eq_g_toMatrix : (G : Matrix (Fin 2) (Fin 2) F) = LinearMap.toMatrix' g := by simp_rw [LinearMap.toMatrix'_toLin' _]
--   let χ := charpoly (G : Matrix (Fin 2) (Fin 2) F)
--   have χ_splits := IsAlgClosed.splits χ
--   have χ_ne_zero : χ ≠ 0 := Monic.ne_zero_of_ne (by simp) (charpoly_monic _)
--   have set_of_roots_eq := Polynomial.degree_eq_card_roots χ_ne_zero χ_splits
--   rw [splits_iff_exists_multiset] at χ_splits
--   obtain ⟨roots, hr⟩ := χ_splits
--   have lc_eq_one : χ.leadingCoeff = 1 := Polynomial.Monic.leadingCoeff $ Matrix.charpoly_monic _
--   simp [lc_eq_one] at hr
--   -- the degree of χ is 2
--   have deg_χ_eq_two : degree χ = 2 := Matrix.charpoly_degree_eq_dim _
--   have natDeg_χ_eq_two : natDegree χ = 2 := natDegree_eq_of_degree_eq_some deg_χ_eq_two
--   -- the multiset containing the roots of χ is 2
--   rw [deg_χ_eq_two] at set_of_roots_eq
--   have roots_eq := deg_χ_eq_two
--   rw [hr] at roots_eq
--   -- if the product of monics is of degree two then the multiset of roots is of size 2
--   simp only [degree_multiset_prod, Multiset.map_map, Function.comp_apply, degree_X_sub_C,
--     Multiset.map_const', Multiset.sum_replicate, nsmul_eq_mul, mul_one] at roots_eq
--   norm_cast at roots_eq
--   -- if the size of the multiset is 2 then there must exist two elements in the multiset
--   -- these elements of the multiset are the eigenvalues
--   rw [Multiset.card_eq_two] at roots_eq
--   obtain ⟨ξ₁, ξ₂, hr'⟩ := roots_eq
--   simp [hr'] at hr
--   let Ξ := minpoly F (G : Matrix (Fin 2) (Fin 2) F)
--   have minpoly_dvd_charpoly : Ξ ∣ χ := Matrix.minpoly_dvd_charpoly _
--   have deg_Ξ: natDegree Ξ ≤ 2 := natDeg_χ_eq_two.symm ▸ natDegree_le_of_dvd minpoly_dvd_charpoly χ_ne_zero
--   rw [hr] at minpoly_dvd_charpoly
--   have Ξ_ne_zero : Ξ ≠ 0 := minpoly.ne_zero_of_finite _ _
--   -- degree of minpoly is either 1 or 2
--   let inst : EuclideanDomain F[X] := by infer_instance
--   have not_associated_to_unit : ¬ (∃ u : F[X], IsUnit u ∧ Associated Ξ u) := by
--     -- Suppose for a contradiction that they are associate
--     intro associated_to_unit
--     have Ξ_is_unit : IsUnit Ξ := by
--       obtain ⟨u, u_is_unit, associated_u_Ξ⟩ := associated_to_unit
--       apply Associated.isUnit associated_u_Ξ.symm u_is_unit
--     -- minpoly is not a unit, a contradiction
--     have Ξ_is_not_a_unit : ¬ IsUnit Ξ := minpoly.not_isUnit _ _
--     contradiction
--   have p₁_is_irreducible : Irreducible (X - C ξ₁) := irreducible_X_sub_C _
--   have p₂_is_irreducible : Irreducible (X - C ξ₂) := irreducible_X_sub_C _

--   -- Therefore, either Ξ is associate to (X - C ξ₁), (X - C ξ₂) or (X - C ξ₁) * (X - C ξ₂)
--   rcases (or_iff_right not_associated_to_unit).mp $ dvd_mul_of_irreducibles p₁_is_irreducible p₂_is_irreducible minpoly_dvd_charpoly
--     with (associate_to_p₁ | associate_to_p₂ | associate_to_χ)
--   -- Ξ is associate to (X - C ξ₁)
--   · have G_eq_diagonal : (G : Matrix (Fin 2) (Fin 2) F) = diagonal (fun _ ↦ ξ₁) := minpoly_eq_X_sub_C_implies_matrix_is_diagonal associate_to_p₁
--     have det_G_is_unit : IsUnit (det (G : Matrix (Fin 2) (Fin 2) F)) := by simp [det_G_ne_zero]
--     have ξ₁_ne_zero : ξ₁ ≠ 0 := by simp [G_eq_diagonal] at det_G_is_unit; simp [det_G_is_unit]
--     use ξ₁, ξ₁
--     constructor
--     · simp [ξ₁_ne_zero]
--     · left
--       rw [isConj_iff]
--       use 1
--       simp
--       ext
--       simp [G_eq_diagonal, GeneralLinearGroup.D, ξ₁_ne_zero, GeneralLinearGroup.toMatrix]
--   -- Ξ is associate to (X - C ξ₂)
--   · have G_eq_diagonal : (G : Matrix (Fin 2) (Fin 2) F) = diagonal (fun _ ↦ ξ₂) := minpoly_eq_X_sub_C_implies_matrix_is_diagonal associate_to_p₂
--     have det_G_is_unit : IsUnit (det (G : Matrix (Fin 2) (Fin 2) F)) := by simp [det_G_ne_zero]
--     have ξ₂_ne_zero : ξ₂ ≠ 0 := by simp [G_eq_diagonal] at det_G_is_unit; simp [det_G_is_unit]
--     use ξ₂, ξ₂
--     constructor
--     · simp [ξ₂_ne_zero]
--     · left
--       rw [isConj_iff]
--       use 1
--       simp
--       ext
--       simp [G_eq_diagonal, GeneralLinearGroup.D, ξ₂_ne_zero, GeneralLinearGroup.toMatrix]
--   -- Ξ is associate to (X - C ξ₁) * (X - C ξ₂)
--   · replace associate_to_χ := associate_to_χ.symm
--     rw [Associated] at associate_to_χ
--     obtain ⟨u, Ξ_eq⟩ := associate_to_χ
--     obtain ⟨u', u'_is_unit, C_u'_eq_u⟩ := Polynomial.isUnit_iff.mp u.isUnit
--     let Ξ' := minpoly F g
--     have aeval_G_eq_zero : aeval (G : Matrix (Fin 2) (Fin 2) F) Ξ = 0 := by apply minpoly.aeval
--     have coe_minpoly : Ξ' = Ξ := Matrix.minpoly_toLin' _
--     have ξ₁_is_root_of_Ξ' : IsRoot Ξ' ξ₁ := by simp_rw [coe_minpoly, ← Ξ_eq, IsRoot.def, eval_mul, eval_sub, eval_X, eval_C, sub_self, zero_mul]
--     have ξ₂_is_root_of_Ξ' : IsRoot Ξ' ξ₂ := by simp_rw [coe_minpoly, ← Ξ_eq, IsRoot.def, eval_mul, eval_sub, eval_X, eval_C, sub_self, mul_zero, zero_mul]
--     rw [← Module.End.hasEigenvalue_iff_isRoot] at ξ₁_is_root_of_Ξ' ξ₂_is_root_of_Ξ'
--     by_cases hξ : ξ₁ ≠ ξ₂
--     · obtain ⟨v₁, hv₁⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₁_is_root_of_Ξ'
--       obtain ⟨v₂, hv₂⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₂_is_root_of_Ξ'
--       -- We define the set of eigenvalues
--       let e : Fin 2 → F := fun n => if n.val = 0 then ξ₁ else ξ₂
--       -- the eigenvalues are distinct
--       have he : Function.Injective e := by
--         intro i j hij
--         fin_cases i <;> fin_cases j
--         · rfl
--         · contradiction
--         · symm at hij; contradiction
--         · rfl
--       -- we define the eigenbasis
--       let b : Fin 2 → (Fin 2  → F) := fun n => if n.val = 0 then v₁ else v₂
--       -- the eigenvectors are linearly independent
--       have lin_ind : LinearIndependent F b := by
--         apply Module.End.eigenvectors_linearIndependent' g e he
--         intro i
--         fin_cases i <;> dsimp [e, b]
--         · exact hv₁
--         · exact hv₂
--       -- dimension of vector space equals 2, so the eigenbasis span the vector space
--       have card_eq : Fintype.card (Fin 2) = finrank F (Fin 2 → F) := by simp
--       -- the eigenvectors span the vector space and thus are a basis
--       let eigenbasis : Basis (Fin 2) F (Fin 2 → F) := basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq
--       let std : Basis (Fin 2) F (Fin 2 → F) := Pi.basisFun F (Fin 2)
--       -- Change of basis from (e₁, e₂) to (v₁, v₂)
--       let eigenbasis_invertible := eigenbasis.invertibleToMatrix std
--       -- We show P⁻¹ * S * P = D ξ₁
--       have reindex : (eigenbasis.toMatrix ⇑std)⁻¹ = std.toMatrix eigenbasis := by
--         rw [Matrix.inv_eq_left_inv]
--         rw [Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]
--       let P' :=  eigenbasis.toMatrix (Pi.basisFun F (Fin 2))
--       have det_P_invertible : Invertible (det P') := by apply Matrix.detInvertibleOfInvertible
--       -- have det_P_is_unit : IsUnit (det P) := by apply isUnit_of_invertible
--       let P := Matrix.GeneralLinearGroup.mk' P' det_P_invertible
--       have P'_eq_coe_P : (P : Matrix (Fin 2) (Fin 2) F) = P' := rfl
--       have key : ∀ x : Fin 2 → F, (P * G * P⁻¹ : Matrix (Fin 2) (Fin 2) F) *ᵥ x = diagonal (fun i => if i = 0 then ξ₁ else ξ₂ ) *ᵥ  x := by
--         intro x
--         simp_rw [G_eq_g_toMatrix]
--         simp only [coe_units_inv, Fin.isValue, P]
--         simp_rw [GeneralLinearGroup.toMatrix, P', reindex, std]
--         rw [← eigenbasis.sum_repr x]
--         rw [← Matrix.mulVec_mulVec]
--         -- simp [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
--         rw [← Basis.linearCombination_repr eigenbasis x]
--         simp [Finsupp.linearCombination]
--         simp [Finsupp.sum]
--         simp [eigenbasis, b]
--         simp [LinearMap.codRestrict]
--         dsimp [lin_ind]
--         sorry
--         -- simp [Basis.smul_apply]
--         -- simp [LinearMap.toMatrix_mulVec_repr]
--       sorry
--     · -- if the eigenvalues are the same
--       -- the generalized eigenspace must span the whole vector space
--       simp at hξ
--       rw [hξ, ← sq] at Ξ_eq
--     -- The minimal polynomial evaluated at M must be 0
--       have aeval_minpoly : aeval (G : Matrix (Fin 2) (Fin 2) F) Ξ = 0 := minpoly.aeval _ _
--     -- We rearrange Ξ_eq to isolate Ξ and plug
--       have ringHom_u'_is_unit : IsUnit ((algebraMap F (Matrix (Fin 2) (Fin 2) F)) u') := RingHom.isUnit_map _ u'_is_unit
--       rw [← Ξ_eq, aeval_mul, ← C_u'_eq_u, aeval_C, IsUnit.mul_left_eq_zero ringHom_u'_is_unit] at aeval_minpoly
--       by_cases h : ∃ v, v ∉ LinearMap.ker (g - ξ₁ • 1)
--       · -- we get the generalized eigenvector
--         obtain ⟨v₁, hv₁⟩ := h
--         -- we use the generalized eigenvector to get the eigenvector
--         let v₂ := (g - ξ₁ • 1) v₁
--         have map_sq_eq_zero : (g - ξ₁ • 1)^2 = 0 := by
--           simp [G_eq_g_toMatrix, algebraMap, Algebra.toRingHom] at aeval_minpoly
--           sorry
--         have v₂_is_eigenvector : (g - ξ₁ • 1) v₂ = 0 := by
--           simp_rw [v₂, ← LinearMap.mul_apply, ← sq, map_sq_eq_zero, LinearMap.zero_apply]
--         sorry
--         -- Every vector is an eigenvector, this contradicts the minimal polynomial being a quadratic
--       · push_neg at h
--         have ker_eq_top : LinearMap.ker (g - ξ₁ • 1) = ⊤ := by
--           ext v; constructor
--           · intro _; simp
--           · intro hv; exact h v
--         rw [LinearMap.ker_eq_top] at ker_eq_top
--         have poly_annhilates_S : aeval (G : Matrix (Fin 2) (Fin 2) F) (X - C ξ₁)  = 0 := by
--           rw [sub_eq_zero] at ker_eq_top
--           rw [ker_eq_top] at G_eq_g_toMatrix
--           simp [G_eq_g_toMatrix, algebraMap, Algebra.toRingHom, smul_one_eq_diagonal]
--         have minpoly_is_minimal : Ξ ∣ (X - C ξ₁) := minpoly.dvd _ _ poly_annhilates_S
--         have contr : degree Ξ ≤ degree (X - C ξ₁) := by apply Polynomial.degree_le_of_dvd minpoly_is_minimal (X_sub_C_ne_zero _)
--         -- Contradiction, minpoly has greater degree than (X - C ξ₁) which is annhilated by S.
--         simp [degree_X_sub_C, ← Ξ_eq, degree_eq_zero_of_isUnit] at contr



-- represenation of vector in terms of basis vectors, for all x : Fin 2 → F, x =  c₁ • v₁ + c₂ • v₂ for some c₁, c₂ ∈ F



-- lemma Matrix.eq_iff_

-- two matrices are the same iff for all vectors x, M x = N x
-- lemma Matrix.eq_iff { n R : Type*} [Fintype n ] [ DecidableEq n] [CommRing R] {M N : Matrix n n R} : M = N ↔

-- If p is associated to q then there exists some unit u, such that p = u * q
-- lemma associated_iff {p q : F[X] }: Associated p q ↔ ∃ u, IsUnit u ∧ p = q * u := by
--   constructor
--   · intro hpq
--     obtain ⟨u, hu⟩ := hpq.symm
--     exact ⟨u, u.isUnit, hu.symm⟩
--   · rintro ⟨u, u_is_unit, hpq⟩
--     rw [Associated]

-- open Polynomial in
-- theorem theorem_1_5₄ [IsAlgClosed F] (S : SL(2,F)) : (∃ δ : Fˣ, IsConj (S.coeToGL) (D δ)) ∨ (∃ τ : F, IsConj (S.coeToGL) (T τ)) := by
--   -- let s := (Matrix.toLin (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) (S : Matrix (Fin 2) (Fin 2) F))
--   let s := Matrix.toLin' (S : Matrix (Fin 2) (Fin 2) F)
--   -- let χ' := LinearMap.charpoly s
--   let χ := charpoly (S : Matrix (Fin 2) (Fin 2) F)
--   have χ_splits := IsAlgClosed.splits χ
--   have χ_ne_zero : χ ≠ 0 := Monic.ne_zero_of_ne (by simp) (charpoly_monic _)
--   have set_of_roots_eq := Polynomial.degree_eq_card_roots χ_ne_zero χ_splits
--   rw [splits_iff_exists_multiset] at χ_splits
--   obtain ⟨roots, hr⟩ := χ_splits
--   have lc_eq_one : χ.leadingCoeff = 1 := Polynomial.Monic.leadingCoeff $ Matrix.charpoly_monic _
--   simp [lc_eq_one] at hr
--   -- the degree of χ is 2
--   have deg_χ_eq_two : degree χ = 2 := Matrix.charpoly_degree_eq_dim _
--   have natDeg_χ_eq_two : natDegree χ = 2 := natDegree_eq_of_degree_eq_some deg_χ_eq_two
--   -- the multiset containing the roots of χ is 2
--   rw [deg_χ_eq_two] at set_of_roots_eq
--   have roots_eq := deg_χ_eq_two
--   rw [hr] at roots_eq
--   -- if the product of monics is of degree two then the multiset of roots is of size 2
--   simp only [degree_multiset_prod, Multiset.map_map, Function.comp_apply, degree_X_sub_C,
--     Multiset.map_const', Multiset.sum_replicate, nsmul_eq_mul, mul_one] at roots_eq
--   norm_cast at roots_eq
--   -- if the size of the multiset is 2 then there must exist two elements in the multiset
--   -- these elements of the multiset are the eigenvalues
--   rw [Multiset.card_eq_two] at roots_eq
--   obtain ⟨ξ₁, ξ₂, hr'⟩ := roots_eq
--   simp [hr'] at hr
--   let Ξ := minpoly F (S : Matrix (Fin 2) (Fin 2) F)
--   have minpoly_dvd_charpoly : Ξ ∣ χ := Matrix.minpoly_dvd_charpoly _
--   have deg_Ξ: natDegree Ξ ≤ 2 := natDeg_χ_eq_two.symm ▸ natDegree_le_of_dvd minpoly_dvd_charpoly χ_ne_zero
--   rw [hr] at minpoly_dvd_charpoly
--   have Ξ_ne_zero : Ξ ≠ 0 := minpoly.ne_zero_of_finite _ _
--   -- degree of minpoly is either 1 or 2
--   have not_associated_to_unit : ¬ (∃ u : F[X], IsUnit u ∧ Associated Ξ u) := by
--     -- Suppose for a contradiction that they are associate
--     intro associated_to_unit
--     have Ξ_is_unit : IsUnit Ξ := by
--       obtain ⟨u, u_is_unit, associated_u_Ξ⟩ := associated_to_unit
--       apply Associated.isUnit associated_u_Ξ.symm u_is_unit
--     -- minpoly is not a unit, a contradiction
--     have Ξ_is_not_a_unit : ¬ IsUnit Ξ := minpoly.not_isUnit _ _
--     contradiction
--   have p₁_is_irreducible : Irreducible (X - C ξ₁) := irreducible_X_sub_C _
--   have p₂_is_irreducible : Irreducible (X - C ξ₂) := irreducible_X_sub_C _
--   -- Therefore, either Ξ is associate to (X - C ξ₁), (X - C ξ₂) or (X - C ξ₁) * (X - C ξ₂)
--   rcases (or_iff_right not_associated_to_unit).mp $ dvd_mul_of_irreducibles p₁_is_irreducible p₂_is_irreducible minpoly_dvd_charpoly
--     with (associated_p₁ | associated_p₂ | associated_χ)
--   · -- We show matrix must be ± 1
--     -- First we show S is diagonal
--     have S_eq_diagonal : (S : Matrix (Fin 2) (Fin 2) F) = diagonal (fun _ ↦ ξ₁) := minpoly_eq_X_sub_C_implies_matrix_is_diagonal associated_p₁
--     have ξ₁_eq : det (S : Matrix (Fin 2) (Fin 2) F) = 1 := SpecialLinearGroup.det_coe S
--     -- Because S has determinant det S = ξ₁^2 = 1, either ξ₁ = 1 or ξ₂ = -1
--     simp [S_eq_diagonal, det_fin_two, ← sq] at ξ₁_eq
--     rcases ξ₁_eq with (ξ₁_eq_one | ξ₁_eq_minus_one)
--     · left
--       use 1, 1
--       simp [ξ₁_eq_one] at S_eq_diagonal
--       simp [SemiconjBy, S_eq_diagonal]
--       apply GL_eq_iff_Matrix_eq S_eq_diagonal
--     · left
--       use -1, 1
--       simp [ξ₁_eq_minus_one, ← Matrix.smul_one_eq_diagonal] at S_eq_diagonal
--       simp [SemiconjBy, S_eq_diagonal]
--       apply GL_eq_iff_Matrix_eq S_eq_diagonal
--   · -- We show the matrix must be ± 1
--     -- First we show S is diagonal
--     have S_eq_diagonal : (S : Matrix (Fin 2) (Fin 2) F) = diagonal (fun _ ↦ ξ₂) := minpoly_eq_X_sub_C_implies_matrix_is_diagonal associated_p₂
--     have ξ₂_eq : det (S : Matrix (Fin 2) (Fin 2) F) = 1 := SpecialLinearGroup.det_coe S
--     simp [S_eq_diagonal, det_fin_two, ← sq] at ξ₂_eq
--     rcases ξ₂_eq with (ξ₂_eq_one | ξ₂_eq_minus_one)
--     · left
--       use 1, 1
--       simp [ξ₂_eq_one] at S_eq_diagonal
--       simp [SemiconjBy, S_eq_diagonal]
--       apply GL_eq_iff_Matrix_eq S_eq_diagonal
--     · left
--       use -1, 1
--       simp [ξ₂_eq_minus_one, ← Matrix.smul_one_eq_diagonal] at S_eq_diagonal
--       simp [SemiconjBy]
--       apply GL_eq_iff_Matrix_eq S_eq_diagonal
--   · obtain ⟨u, hu⟩ := associated_χ
--     have Ξ_eq : ∃ u_inv, IsUnit u_inv ∧ Ξ = (X - C ξ₁) * (X - C ξ₂) * u_inv := ⟨u.inv, by simp [← hu]⟩
--     -- We rearrange Ξ_eq to isolate Ξ, then we substitute
--     obtain ⟨u_inv, u_inv_is_unit, Ξ_eq⟩ := Ξ_eq
--     obtain ⟨u_inv', u_inv'_is_unit, C_u_inv'_eq_u_inv⟩ := Polynomial.isUnit_iff.mp u_inv_is_unit
--     -- let s := (Matrix.toLin' (S : Matrix (Fin 2) (Fin 2) F))
--     let s := (Matrix.toLin (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) (S : Matrix (Fin 2) (Fin 2) F))
--     let Ξ' := minpoly F s
--     have coe : Ξ' = Ξ := Matrix.minpoly_toLin' _
--     have ξ₁_is_root_of_Ξ' : IsRoot Ξ' ξ₁ := by simp only [coe, Ξ_eq, IsRoot.def, eval_mul,
--       eval_sub, eval_X, eval_C, sub_self, zero_mul]
--     have ξ₂_is_root_of_Ξ' : IsRoot Ξ' ξ₂ := by simp [Ξ_eq, coe]
--     rw [← Module.End.hasEigenvalue_iff_isRoot] at ξ₁_is_root_of_Ξ' ξ₂_is_root_of_Ξ'
--     by_cases hξ : ξ₁ ≠ ξ₂
--     · left
--       obtain ⟨v₁, hv₁⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₁_is_root_of_Ξ'
--       obtain ⟨v₂, hv₂⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₂_is_root_of_Ξ'
--       -- we define the set of eigenvalues
--       let e : Fin 2 → F := fun n => if n.val = 0 then ξ₁ else ξ₂
--       -- the eigenvalues are distinct
--       have he : Function.Injective e := by
--         intro i j hij
--         fin_cases i <;> fin_cases j
--         · rfl
--         · contradiction
--         · symm at hij; contradiction
--         · rfl
--       -- we define the eigenbasis
--       let b : Fin 2 → (Fin 2  → F) := fun n => if n.val = 0 then v₁ else v₂
--       -- the eigenvectors are linearly independent
--       have lin_ind : LinearIndependent F b := by
--         apply Module.End.eigenvectors_linearIndependent' s e he
--         intro i
--         fin_cases i <;> dsimp [e, b]
--         · exact hv₁
--         · exact hv₂
--       -- dimension of vector space equals 2
--       have card_eq : Fintype.card (Fin 2) = finrank F (Fin 2 → F) := by simp
--       -- the eigenvectors span the vector space and thus are a basis
--       let eigenbasis : Basis (Fin 2) F (Fin 2 → F) := basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq
--       -- Change of basis from (e₁, e₂) to (v₁, v₂)
--       let eigenbasis_invertible := eigenbasis.invertibleToMatrix (Pi.basisFun F (Fin 2))
--       -- We show P⁻¹ * S * P = D ξ₁
--       have reindex : (eigenbasis.toMatrix ⇑(Pi.basisFun F (Fin 2)))⁻¹ = (Pi.basisFun F (Fin 2)).toMatrix eigenbasis := by
--         rw [Matrix.inv_eq_left_inv]
--         simp [Matrix.inv_eq_left_inv, Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]
--       let P' :=  eigenbasis.toMatrix (Pi.basisFun F (Fin 2))
--       have det_P_invertible : Invertible (det P') := by apply Matrix.detInvertibleOfInvertible
--       -- have det_P_is_unit : IsUnit (det P) := by apply isUnit_of_invertible
--       let P := Matrix.GeneralLinearGroup.mk' P' det_P_invertible
--       have P'_eq_coe_P : (P : Matrix (Fin 2) (Fin 2) F) = P' := rfl
--       have S_as_linear_map : (S : Matrix (Fin 2) (Fin 2) F) = LinearMap.toMatrix (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) s := by simp only [LinearMap.toMatrix_toLin,
--         s]
--       have key : ∀ x : Fin 2 → F, (P * S * P⁻¹ : Matrix (Fin 2) (Fin 2) F) *ᵥ x = diagonal (fun i => if i = 0 then ξ₁ else ξ₂ ) *ᵥ  x := by
--         intro x
--         rw [S_as_linear_map]
--         simp [P]
--         simp_rw [GeneralLinearGroup.toMatrix, P', reindex]
--         simp [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
--         rw [← Basis.linearCombination_repr eigenbasis x]
--         simp [Finsupp.linearCombination]
--         simp [Finsupp.sum]
--         simp [eigenbasis]
--         simp [LinearMap.codRestrict]
--         dsimp [lin_ind]
--         sorry
--         -- simp [Basis.smul_apply]
--         -- simp [LinearMap.toMatrix_mulVec_repr]
--       sorry
--     · -- if the eigenvalues are the same
--       -- the generalized eigenspace must span the whole vector space
--       simp at hξ
--       rw [hξ, ← sq] at Ξ_eq
--     -- The minimal polynomial evaluated at M must be 0
--       have aeval_minpoly : aeval (S : Matrix (Fin 2) (Fin 2) F) Ξ = 0 := minpoly.aeval _ _
--     -- We rearrange Ξ_eq to isolate Ξ and plug
--       have ringHom_u_inv'_is_unit : IsUnit ((algebraMap F (Matrix (Fin 2) (Fin 2) F)) u_inv') := RingHom.isUnit_map _ u_inv'_is_unit
--       rw [Ξ_eq, aeval_mul, ← C_u_inv'_eq_u_inv, aeval_C, IsUnit.mul_left_eq_zero ringHom_u_inv'_is_unit] at aeval_minpoly
--       -- simp at genEigen_rank2
--       -- eigenvector of s
--       -- obtain ⟨v₁, hv₁⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₁_is_root_of_Ξ'
--       -- there exists a generalized eigenvector
--       have S_as_linear_map : (S : Matrix (Fin 2) (Fin 2) F) = LinearMap.toMatrix (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) s := by simp only [LinearMap.toMatrix_toLin, s]
--       by_cases h : ∃ v, v ∉ LinearMap.ker (s - ξ₁ • 1)
--       · -- we get the generalized eigenvector
--         obtain ⟨v₁, hv₁⟩ := h
--         -- we use the generalized eigenvector to get the eigenvector
--         let v₂ := (s - ξ₁ • 1) v₁
--         have map_sq_eq_zero : (s - ξ₁ • 1)^2 = 0 := by
--           simp [S_as_linear_map, algebraMap, Algebra.toRingHom] at aeval_minpoly
--           sorry
--         have v₂_is_eigenvector : (s - ξ₁ • 1) v₂ = 0 := by
--           simp_rw [v₂, ← LinearMap.mul_apply, ← sq, map_sq_eq_zero, LinearMap.zero_apply]
--         sorry
--         -- every vector is an eigenvector
--       · push_neg at h
--         have ker_eq_top : LinearMap.ker (s - ξ₁ • 1) = ⊤ := by
--           ext v; constructor
--           · intro _; simp
--           · intro hv; exact h v
--         rw [LinearMap.ker_eq_top] at ker_eq_top
--         have poly_annhilates_S : aeval (S : Matrix (Fin 2) (Fin 2) F) (X - C ξ₁)  = 0 := by
--           rw [sub_eq_zero] at ker_eq_top
--           rw [ker_eq_top] at S_as_linear_map
--           simp [S_as_linear_map, algebraMap, Algebra.toRingHom, smul_one_eq_diagonal]
--         have minpoly_is_minimal : Ξ ∣ (X - C ξ₁) := minpoly.dvd _ _ poly_annhilates_S
--         have contr : degree Ξ ≤ degree (X - C ξ₁) := by apply Polynomial.degree_le_of_dvd minpoly_is_minimal (X_sub_C_ne_zero _)
--         -- contradiction, minpoly has greater degree than (X - C ξ₁) which is annhilated by S.
--         simp [degree_X_sub_C, Ξ_eq, degree_eq_zero_of_isUnit u_inv_is_unit] at contr


-- open Polynomial in
-- theorem theorem_1_5₅ [IsAlgClosed F] (S : SL(2,F)) : (∃ δ : Fˣ, IsConj (S.coeToGL) (D δ)) ∨ (∃ τ : F, IsConj (S.coeToGL) (T τ)) := by
--   -- let s := (Matrix.toLin (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) (S : Matrix (Fin 2) (Fin 2) F))
--   let s := Matrix.toLin' (S : Matrix (Fin 2) (Fin 2) F)
--   have s_eq_S_toLin : s = Matrix.toLin' (S : Matrix (Fin 2) (Fin 2) F) := rfl
--   have S_eq_s_toMatrix : S = LinearMap.toMatrix' s := by simp [s]
--   -- let χ' := LinearMap.charpoly s
--   let χ := LinearMap.charpoly s
--   have χ_splits := IsAlgClosed.splits χ
--   have χ_ne_zero : χ ≠ 0 := Monic.ne_zero_of_ne (by simp) (charpoly_monic _)
--   have set_of_roots_eq := Polynomial.degree_eq_card_roots χ_ne_zero χ_splits
--   rw [splits_iff_exists_multiset] at χ_splits
--   obtain ⟨roots, hr⟩ := χ_splits
--   have lc_eq_one : χ.leadingCoeff = 1 := Polynomial.Monic.leadingCoeff $ Matrix.charpoly_monic _
--   simp [lc_eq_one] at hr
--   -- the degree of χ is 2
--   have finrank_eq_two : finrank F (Fin 2 → F) = 2 := by simp
--   have natDeg_χ_eq_two : natDegree χ = 2 := finrank_eq_two.symm ▸ LinearMap.charpoly_natDegree _
--   have deg_χ_eq_two : degree χ = (2 : ℕ) := by rw [degree_eq_iff_natDegree_eq χ_ne_zero]; exact natDeg_χ_eq_two
--   -- the multiset containing the roots of χ is 2
--   rw [deg_χ_eq_two ] at set_of_roots_eq
--   have roots_eq := deg_χ_eq_two
--   rw [hr] at roots_eq
--   -- if the product of monics is of degree two then the multiset of roots is of size 2
--   simp only [degree_multiset_prod, Multiset.map_map, Function.comp_apply, degree_X_sub_C,
--     Multiset.map_const', Multiset.sum_replicate, nsmul_eq_mul, mul_one] at roots_eq
--   norm_cast at roots_eq
--   -- if the size of the multiset is 2 then there must exist two elements in the multiset
--   -- these elements of the multiset are the eigenvalues
--   rw [Multiset.card_eq_two] at roots_eq
--   obtain ⟨ξ₁, ξ₂, hr'⟩ := roots_eq
--   simp [hr'] at hr
--   let Ξ := minpoly F s
--   have minpoly_dvd_charpoly : Ξ ∣ χ := LinearMap.minpoly_dvd_charpoly _
--   have deg_Ξ: natDegree Ξ ≤ 2 := natDeg_χ_eq_two.symm ▸ natDegree_le_of_dvd minpoly_dvd_charpoly χ_ne_zero
--   rw [hr] at minpoly_dvd_charpoly
--   have Ξ_ne_zero : Ξ ≠ 0 := minpoly.ne_zero_of_finite _ _
--   -- degree of minpoly is either 1 or 2
--   let inst : EuclideanDomain F[X] := by infer_instance
--   have not_associated_to_unit : ¬ (∃ u : F[X], IsUnit u ∧ Associated Ξ u) := by
--     -- Suppose for a contradiction that they are associate
--     intro associated_to_unit
--     have Ξ_is_unit : IsUnit Ξ := by
--       obtain ⟨u, u_is_unit, associated_u_Ξ⟩ := associated_to_unit
--       apply Associated.isUnit associated_u_Ξ.symm u_is_unit
--     -- minpoly is not a unit, a contradiction
--     have Ξ_is_not_a_unit : ¬ IsUnit Ξ := minpoly.not_isUnit _ _
--     contradiction
--   have p₁_is_irreducible : Irreducible (X - C ξ₁) := irreducible_X_sub_C _
--   have p₂_is_irreducible : Irreducible (X - C ξ₂) := irreducible_X_sub_C _
--   -- Therefore, either Ξ is associate to (X - C ξ₁), (X - C ξ₂) or (X - C ξ₁) * (X - C ξ₂)
--   rcases (or_iff_right not_associated_to_unit).mp $ dvd_mul_of_irreducibles p₁_is_irreducible p₂_is_irreducible minpoly_dvd_charpoly
--     with (associated_p₁ | associated_p₂ | associated_χ)
--   · -- We show matrix must be ± 1
--     -- First we show S is diagonal
--     have s_eq_smul_one : s = ξ₁ • 1 := smul_one_of_minpoly_eq_X_sub_C associated_p₁
--     have ξ₁_eq : LinearMap.det s = (1 : F) := by simp [s]
--     -- Because S has determinant det S = ξ₁^2 = 1, either ξ₁ = 1 or ξ₂ = -1
--     simp [s_eq_smul_one, det_fin_two, ← sq] at ξ₁_eq
--     rcases ξ₁_eq with (ξ₁_eq_one | ξ₁_eq_minus_one)
--     · left
--       use 1, 1
--       simp [ξ₁_eq_one] at s_eq_smul_one
--       simp [SemiconjBy, s_eq_smul_one]
--       apply lin_map_eq_iff_matrix_eq
--       -- rw [← s_eq_S_toLin]
--       sorry
--       -- apply GL_eq_iff_Matrix_eq s_eq_smul_one
--     · left
--       use -1, 1
--       simp [ξ₁_eq_minus_one, ← Matrix.smul_one_eq_diagonal] at s_eq_smul_one
--       simp [SemiconjBy, s_eq_smul_one]
--       -- apply GL_eq_iff_Matrix_eq s_eq_smul_one
--       sorry
--   · -- We show the matrix must be ± 1
--     -- First we show S is diagonal
--     sorry
--     -- have S_eq_diagonal : (S : Matrix (Fin 2) (Fin 2) F) = diagonal (fun _ ↦ ξ₂) := minpoly_eq_X_sub_C_implies_matrix_is_diagonal associated_p₂
--     -- have ξ₂_eq : det (S : Matrix (Fin 2) (Fin 2) F) = 1 := SpecialLinearGroup.det_coe S
--     -- simp [S_eq_diagonal, det_fin_two, ← sq] at ξ₂_eq
--     -- rcases ξ₂_eq with (ξ₂_eq_one | ξ₂_eq_minus_one)
--     -- · left
--     --   use 1, 1
--     --   simp [ξ₂_eq_one] at S_eq_diagonal
--     --   simp [SemiconjBy, S_eq_diagonal]
--     --   apply GL_eq_iff_Matrix_eq S_eq_diagonal
--     -- · left
--     --   use -1, 1
--     --   simp [ξ₂_eq_minus_one, ← Matrix.smul_one_eq_diagonal] at S_eq_diagonal
--     --   simp [SemiconjBy]
--     --   apply GL_eq_iff_Matrix_eq S_eq_diagonal
--   · obtain ⟨u, hu⟩ := associated_χ
--     have Ξ_eq : ∃ u_inv, IsUnit u_inv ∧ Ξ = (X - C ξ₁) * (X - C ξ₂) * u_inv := ⟨u.inv, by simp [← hu]⟩
--     -- We rearrange Ξ_eq to isolate Ξ, then we substitute
--     obtain ⟨u_inv, u_inv_is_unit, Ξ_eq⟩ := Ξ_eq
--     obtain ⟨u_inv', u_inv'_is_unit, C_u_inv'_eq_u_inv⟩ := Polynomial.isUnit_iff.mp u_inv_is_unit
--     -- let s := (Matrix.toLin' (S : Matrix (Fin 2) (Fin 2) F))
--     -- let s := (Matrix.toLin (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) (S : Matrix (Fin 2) (Fin 2) F))
--     -- let Ξ' := minpoly F s
--     -- have coe : Ξ' = Ξ := Matrix.minpoly_toLin' _
--     have ξ₁_is_root_of_Ξ : IsRoot Ξ ξ₁ := by simp [Ξ_eq]
--     have ξ₂_is_root_of_Ξ : IsRoot Ξ ξ₂ := by simp [Ξ_eq]
--     rw [← Module.End.hasEigenvalue_iff_isRoot] at ξ₁_is_root_of_Ξ ξ₂_is_root_of_Ξ
--     by_cases hξ : ξ₁ ≠ ξ₂
--     · left
--       obtain ⟨v₁, hv₁⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₁_is_root_of_Ξ
--       obtain ⟨v₂, hv₂⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₂_is_root_of_Ξ
--       -- we define the set of eigenvalues
--       let e : Fin 2 → F := fun n => if n.val = 0 then ξ₁ else ξ₂
--       -- the eigenvalues are distinct
--       have he : Function.Injective e := by
--         intro i j hij
--         fin_cases i <;> fin_cases j
--         · rfl
--         · contradiction
--         · symm at hij; contradiction
--         · rfl
--       -- we define the eigenbasis
--       let b : Fin 2 → (Fin 2  → F) := fun n => if n.val = 0 then v₁ else v₂
--       -- the eigenvectors are linearly independent
--       have lin_ind : LinearIndependent F b := by
--         apply Module.End.eigenvectors_linearIndependent' s e he
--         intro i
--         fin_cases i <;> dsimp [e, b]
--         · exact hv₁
--         · exact hv₂
--       -- dimension of vector space equals 2
--       have card_eq : Fintype.card (Fin 2) = finrank F (Fin 2 → F) := by simp
--       -- the eigenvectors span the vector space and thus are a basis
--       let eigenbasis : Basis (Fin 2) F (Fin 2 → F) := basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq
--       -- Change of basis from (e₁, e₂) to (v₁, v₂)
--       let eigenbasis_invertible := eigenbasis.invertibleToMatrix (Pi.basisFun F (Fin 2))
--       -- We show P⁻¹ * S * P = D ξ₁
--       have ξ₁_is_unit : IsUnit ξ₁ := by sorry -- this is a stub
--       use IsUnit.unit ξ₁_is_unit
--       let P' :=  eigenbasis.toMatrix (Pi.basisFun F (Fin 2))
--       have det_P_invertible : Invertible (det P') := by apply Matrix.detInvertibleOfInvertible
--       -- have det_P_is_unit : IsUnit (det P) := by apply isUnit_of_invertible
--       let P := Matrix.GeneralLinearGroup.mk' P' det_P_invertible
--       -- have P_is_unit : IsUnit P := by rw [Matrix.isUnit_iff_isUnit_det]; apply det_P_is_unit
--       -- have S_as_linear_map : (S : Matrix (Fin 2) (Fin 2) F) = LinearMap.toMatrix (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) s := by simp [s]
--       -- rw [isConj_iff (S : Matrix (Fin 2) (Fin 2) F) _]
--       -- use (IsUnit.unit P_is_unit)⁻¹
--       simp
--       use P
--       have reindex : (eigenbasis.toMatrix ⇑(Pi.basisFun F (Fin 2)))⁻¹ = (Pi.basisFun F (Fin 2)).toMatrix eigenbasis := by sorry -- simp [Basis.toMatrix_mul_toMatrix_flip ]
--       -- coerce to Matrix
--       have key : (P * S * P⁻¹ : Matrix (Fin 2) (Fin 2) F) = ((D ξ₁_is_unit.unit) : Matrix (Fin 2) (Fin 2) F) := by
--         rw [S_eq_s_toMatrix]
--         simp [P]
--         simp_rw [GeneralLinearGroup.toMatrix, P', reindex]
--         -- simp [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
--         -- apply Basis.ext
--         -- when applying
--         let std := Pi.basisFun F (Fin 2)
--         have v₁_repr_std := Basis.linearCombination_repr std v₁
--         have v₂_repr_std := Basis.linearCombination_repr std v₂
--         ext i j
--         rw [D_eq_diagonal]
--         sorry
--       -- have := Basis.invertibleToMatrix.proof_2 eigenbasis (Pi.basisFun F (Fin 2))
--       apply GL_eq_iff_Matrix_eq key
--     · -- if the eigenvalues are the same
--       -- the generalized eigenspace must span the whole vector space
--       simp at hξ
--       rw [hξ, ← sq] at Ξ_eq
--     -- The minimal polynomial evaluated at M must be 0
--       have aeval_minpoly : aeval s Ξ = 0 := minpoly.aeval _ _
--     -- We rearrange Ξ_eq to isolate Ξ and plug
--       have ringHom_u_inv'_is_unit : IsUnit ((algebraMap F (Matrix (Fin 2) (Fin 2) F)) u_inv') := RingHom.isUnit_map _ u_inv'_is_unit
--       rw [Ξ_eq, aeval_mul, ← C_u_inv'_eq_u_inv, aeval_C, IsUnit.mul_left_eq_zero ringHom_u_inv'_is_unit] at aeval_minpoly
--       -- simp at genEigen_rank2
--       -- eigenvector of s
--       -- obtain ⟨v₁, hv₁⟩ := Module.End.HasEigenvalue.exists_hasEigenvector ξ₁_is_root_of_Ξ'
--       -- there exists a generalized eigenvector
--       have S_as_linear_map : (S : Matrix (Fin 2) (Fin 2) F) = LinearMap.toMatrix (Pi.basisFun F (Fin 2)) (Pi.basisFun F (Fin 2)) s := by simp [s]
--       by_cases h : ∃ v, v ∉ LinearMap.ker (s - ξ₁ • 1)
--       · -- we get the generalized eigenvector
--         obtain ⟨v₁, hv₁⟩ := h
--         -- we use the generalized eigenvector to get the eigenvector
--         let v₂ := (s - ξ₁ • 1) v₁
--         have map_sq_eq_zero : (s - ξ₁ • 1)^2 = 0 := by
--           simp [S_as_linear_map, algebraMap, Algebra.toRingHom] at aeval_minpoly
--           sorry
--         have v₂_is_eigenvector : (s - ξ₁ • 1) v₂ = 0 := by
--           simp_rw [v₂, ← LinearMap.mul_apply, ← sq, map_sq_eq_zero, LinearMap.zero_apply]
--         sorry
--         -- every vector is an eigenvector
--       · push_neg at h
--         have ker_eq_top : LinearMap.ker (s - ξ₁ • 1) = ⊤ := by
--           ext v; constructor
--           · intro _; simp
--           · intro hv; exact h v
--         rw [LinearMap.ker_eq_top] at ker_eq_top
--         have poly_annhilates_S : aeval (S : Matrix (Fin 2) (Fin 2) F) (X - C ξ₁)  = 0 := by
--           rw [sub_eq_zero] at ker_eq_top
--           rw [ker_eq_top] at S_as_linear_map
--           simp [S_as_linear_map, algebraMap, Algebra.toRingHom, smul_one_eq_diagonal]
--         have minpoly_is_minimal : Ξ ∣ (X - C ξ₁) := minpoly.dvd _ _ poly_annhilates_S
--         have contr : degree Ξ ≤ degree (X - C ξ₁) := by apply Polynomial.degree_le_of_dvd minpoly_is_minimal (X_sub_C_ne_zero _)
--         -- contradiction, minpoly has greater degree than (X - C ξ₁) which is annhilated by S.
--         simp [degree_X_sub_C, Ξ_eq, degree_eq_zero_of_isUnit u_inv_is_unit] at contr
